{"file":"posts/2017-01-22-fiddling-with-asp-dotnet-core-and-fsharp-with-suave.md","type":"posts","slug":"posts/fiddling-with-asp-dotnet-core-and-fsharp-with-suave","date":"2017-01-22T23:00:25.000Z","title":"Fiddling with ASP.NET Core and F# with Suave","tags":[".net","fsharp"],"author":"shane","categories":["All Posts","Programming"],"description":"Suave is a possible replacement for the ASP.NET stack, but with some help, the two can be used together to build composable F# web applications.","content":"<p>ASP.NET is a great framework for building web applications. It&#39;s tried and trusted, fully extensible, has a great community, and thanks to .NET Core, supported across Linux, MacOS, and Windows. Being built with .NET, we have the wise option of building our application with F#, but without intervention, we&#39;d be stuck with using the object-oriented C# types that are throughout ASP.NET.</p>\n<h2 id=\"the-setup\">The Setup</h2>\n<p>To overcome this, we&#39;ll leverage <a href=\"https://suave.io/\">Suave</a>, which can be a full replacement for ASP.NET, and <a href=\"https://github.com/dustinmoris/Suave.AspNetCore\"><code>Suave.AspNetCore</code></a> to tie the two together. Let&#39;s start with a generated project thanks to <a href=\"https://github.com/OmniSharp/generator-aspnet\"><code>yo aspnet</code></a> and the <code>Web API Application (F#)</code> template it provides, stripping out some of the template&#39;s defaults to have a blank slate. We&#39;ll still have some of that object-oriented C# feel, but it will be restricted to the console application:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">open</span> System.IO\n<span class=\"hljs-keyword\">open</span> Microsoft.Extensions.Configuration\n<span class=\"hljs-keyword\">open</span> Microsoft.AspNetCore.Hosting\n<span class=\"hljs-keyword\">open</span> ProjectName\n\n<span class=\"hljs-meta\">[&lt;EntryPoint&gt;]</span>\n<span class=\"hljs-keyword\">let</span> main argv =\n  <span class=\"hljs-keyword\">let</span> config = ConfigurationBuilder()\n                  .AddCommandLine(argv)\n                  .AddEnvironmentVariables(<span class=\"hljs-string\">\"ASPNETCORE_\"</span>)\n                  .Build()\n\n  <span class=\"hljs-keyword\">let</span> host = WebHostBuilder()\n                  .UseConfiguration(config)\n                  .UseKestrel()\n                  .UseContentRoot(Directory.GetCurrentDirectory())\n                  .UseIISIntegration()\n                  .UseStartup&lt;Http.Startup&gt;()\n                  .Build()\n  host.Run()\n  <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// exit code</span>\n</code></pre>\n<p>and a minimal <code>Startup</code> class:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">namespace</span> ProjectName\n\n<span class=\"hljs-keyword\">open</span> Microsoft.AspNetCore.Builder\n<span class=\"hljs-keyword\">open</span> Microsoft.AspNetCore.Hosting\n<span class=\"hljs-keyword\">open</span> Microsoft.Extensions.DependencyInjection\n<span class=\"hljs-keyword\">open</span> Microsoft.Extensions.Logging\n<span class=\"hljs-keyword\">open</span> Suave.AspNetCore\n\n<span class=\"hljs-keyword\">module</span> Http =\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Startup</span></span>() =\n    <span class=\"hljs-keyword\">member</span> this.ConfigureServices (services : IServiceCollection) = ()\n\n    <span class=\"hljs-keyword\">member</span> this.Configure (app : IApplicationBuilder, env : IHostingEnvironment, loggerFactory : ILoggerFactory) =\n      app.UseSuave(App.app) |&gt; ignore\n</code></pre>\n<p><code>Suave.AspNetCore</code> exposes a <code>UseSuave</code> extension method on ASP.NET&#39;s <code>ApplicationBuilder</code> that acts as the connection point between ASP.NET and Suave. Overall, <code>Suave.AspNetCore</code> accomplishes this connection through two main pieces:</p>\n<ol>\n<li>A <code>SuaveMiddleware</code> that implements <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware\">ASP.NET Middleware</a>&#39;s method signatures</li>\n<li>A bi-directional mapping between ASP.NET&#39;s <code>HttpContext</code> and Suave&#39;s <code>HttpContext</code></li>\n</ol>\n<p>We can use Suave&#39;s API to control request/response pipeline from here, sticking to full F# and Suave&#39;s <code>HttpContext</code> (opposed to the ASP.NET <code>HttpContext</code>).</p>\n<h2 id=\"why-all-this-trouble-\">Why all this trouble?</h2>\n<p>We&#39;re going through this setup to leverage one of Suave&#39;s core principles: the <code>WebPart</code>. From Suave&#39;s documentation:</p>\n<blockquote>\n<p>A web part is a thing that acts on a HttpContext, the web part could fail by returning <code>None</code> or succeed and produce a new HttpContext. Each web part can execute asynchronously, and it’s not until it is evaluated that the async is evaluated. It will be evaluated on the same fibre (asynchronous execution context) that is consuming from the browser’s TCP socket.</p>\n</blockquote>\n<p><code>WebPart</code>s give two benefits, composability (combining small pieces into larger ones) and asynchronism (which also aids in composability). In essence, it&#39;s type boils down to this (which is useful to know as your editor may display either the left-hand side or the right-hand side depending on how F# infers the type for a given expression):</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">WebPart</span> </span>= HttpContext -&gt; Async&lt;HttpContext option&gt;\n</code></pre>\n<p>where each <code>WebPart</code> accepts Suave&#39;s <code>HttpContext</code> and returns an async option. The option is what gives applications the ability to control execution flow. When execution of a code path should stop, the <code>WebPart</code> will return <code>None</code>, but otherwise, it will return <code>Some httpContext</code> with a new <code>HttpContext</code> with any desired updates. Because this process is wrapped in <code>async</code>, we aren&#39;t penalized too much as our application decides how to handle an incoming request.</p>\n<blockquote>\n<p>One note to make is that instead of F#&#39;s normal function composition operator (<code>&gt;&gt;</code>), Suave exposes a fish operator (<code>&gt;=&gt;</code>) to aid in working with <code>WebPart</code>s and removes some necessary handling of <code>Async&lt;HttpContext option&gt;</code> that aids developer productivity. We&#39;ll see this operator in action later on as we build up our application.</p>\n</blockquote>\n<h2 id=\"composing-an-application\">Composing an application</h2>\n<p>For now, let&#39;s just begin with a small starter <code>WebPart</code>, thanks to <code>OK</code>:</p>\n<pre><code class=\"hljs language-fsharp\">namepsace ProjectName\n\n<span class=\"hljs-keyword\">open</span> Suave\n<span class=\"hljs-keyword\">open</span> Helpers\n<span class=\"hljs-keyword\">open</span> Suave.Filters\n<span class=\"hljs-keyword\">open</span> Suave.Operators\n<span class=\"hljs-keyword\">open</span> Suave.RequestErrors\n<span class=\"hljs-keyword\">open</span> Suave.Successful\n\n<span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-keyword\">let</span> hello name = OK (<span class=\"hljs-string\">\"hello \"</span> + name)\n  <span class=\"hljs-keyword\">let</span> app = hello <span class=\"hljs-string\">\"world\"</span>\n</code></pre>\n<p>As our application grows, we&#39;ll use <code>choose</code> to facilitate paths a request may take and <code>path</code> to filter part of the decision tree based on request path. Here, we add some basic routes:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">let</span> app =\n    choose [\n      path <span class=\"hljs-string\">\"/\"</span> &gt;=&gt; hello <span class=\"hljs-string\">\"world\"</span>\n      path <span class=\"hljs-string\">\"/api\"</span> &gt;=&gt; NO_CONTENT\n      path <span class=\"hljs-string\">\"/api/users\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"users\"</span>\n    ]\n</code></pre>\n<p>Not only can we use these combinators to create a decision tree to route requests, we can also create a <code>WebPart</code>s to set a header or affect the context other ways:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">let</span> setServerHeader =\n    Writers.setHeader <span class=\"hljs-string\">\"server\"</span> <span class=\"hljs-string\">\"kestrel + suave\"</span>\n\n  <span class=\"hljs-keyword\">let</span> app =\n    setServerHeader\n    &gt;=&gt; choose [\n      <span class=\"hljs-comment\">// ...</span>\n    ]\n</code></pre>\n<p>We&#39;ve added <code>setServerHeader</code> in our <code>app</code> expression at the top level, but it would be just as happy deeper in the expression. <code>path</code> can prevent further combinators from affecting the response, so if <code>setServerHeader</code> is added after a <code>path</code> expression (or some similar combinator), the response will only have the header set if that part of the decision tree is successfull. For instance, with:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">let</span> app =\n    choose [\n      path <span class=\"hljs-string\">\"/server\"</span> &gt;=&gt; setServerHeader &gt;=&gt; OK <span class=\"hljs-string\">\"server\"</span>\n      path <span class=\"hljs-string\">\"/no-server\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"no-server\"</span>\n    ]\n</code></pre>\n<p>responses for <code>/server</code> will have the <code>Server</code> header set with the value <code>kestrel + suave</code>, while responses for <code>/no-server</code> will have the default value set for the <code>Server</code> header, thanks to the <code>WebPart</code> type (remember, it returns an <code>Async&lt;HttpContext option&gt;</code>).</p>\n<p>We can also use <code>WebPart</code>s to compose multiple application segments, introducing some order as our application grows:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">let</span> api =\n    Writers.setMimeType <span class=\"hljs-string\">\"\"\"application/json; charset=\"utf-8\";\"\"\"</span>\n    &gt;=&gt; choose [\n          path <span class=\"hljs-string\">\"/api\"</span> &gt;=&gt; NO_CONTENT\n          path <span class=\"hljs-string\">\"/api/users\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"\"\"{\"api\": \"users\"}\"\"\"</span>\n        ]\n\n  <span class=\"hljs-keyword\">let</span> web =\n    choose [\n      path <span class=\"hljs-string\">\"/\"</span> &gt;=&gt; hello <span class=\"hljs-string\">\"world\"</span>\n      pathScan <span class=\"hljs-string\">\"/hello/%s\"</span> hello\n    ]\n\n  <span class=\"hljs-keyword\">let</span> app = [ api; web; ]\n</code></pre>\n<h2 id=\"iterating-improvements\">Iterating improvements</h2>\n<p>Let&#39;s see if we can clean up <code>api</code> to remove some duplication. I saw this pattern out on the web at some point:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">module</span> Paths =\n  <span class=\"hljs-keyword\">module</span> Api =\n    <span class=\"hljs-keyword\">let</span> root = <span class=\"hljs-string\">\"/api\"</span>\n    <span class=\"hljs-keyword\">let</span> users = root + <span class=\"hljs-string\">\"/users\"</span>\n\n<span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">let</span> api =\n    Writers.setMimeType <span class=\"hljs-string\">\"\"\"application/json; charset=\"utf-8\";\"\"\"</span>\n    &gt;=&gt; choose [\n          path Paths.Api.root &gt;=&gt; NO_CONTENT\n          path Paths.Api.users &gt;=&gt; OK <span class=\"hljs-string\">\"\"\"{\"api\": \"users\"}\"\"\"</span>\n        ]\n\n  <span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>I like the separation here, but honestly, I&#39;m not sure it helps the situation much. We still have a similar problem, plus the additional code for managing the paths. Still not acceptable in my book, so lets try something else. My next inclination is to attempt to nest <code>path</code> expressions:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">let</span> api =\n    Writers.setMimeType <span class=\"hljs-string\">\"\"\"application/json; charset=\"utf-8\";\"\"\"</span>\n    &gt;=&gt; path <span class=\"hljs-string\">\"/api\"</span>\n    &gt;=&gt; choose [\n          path <span class=\"hljs-string\">\"\"</span> &gt;=&gt; NO_CONTENT\n          path <span class=\"hljs-string\">\"/users\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"\"\"{\"api\": \"users\"}\"\"\"</span>\n        ]\n\n  <span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>Sadly, this doesn&#39;t work as expected and results in a <code>404 Not Found</code>. I wasn&#39;t lucky in looking for an official solution yet, but are custom combinators an option? Let&#39;s try to build one. Here&#39;s what <code>path</code>&#39;s implementation looks like:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">let</span> path s (x : HttpContext) =\n  <span class=\"hljs-comment\">// `iff` was internalized to simplify for display here</span>\n  <span class=\"hljs-keyword\">let</span> iff b x =\n    <span class=\"hljs-keyword\">if</span> b <span class=\"hljs-keyword\">then</span> Some x <span class=\"hljs-keyword\">else</span> None\n  async.Return (iff (s = x.request.path) x)\n</code></pre>\n<p>Essentially, it checks the path given to <code>path</code> against the request&#39;s path, returning <code>None</code> if there&#39;s no match. For our custom combinators, we&#39;ll need to check the request path against the string passed to our new <code>path</code> as well as the path set above it. <code>HttpContext</code> has a <code>userState</code> field, meant for storing state information within a single request, perfect for our use-case of storing info about the entire path for a given code path. Here are our new combinators:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">let</span> optionally pred value =\n    <span class=\"hljs-keyword\">if</span> pred <span class=\"hljs-keyword\">then</span> Some value <span class=\"hljs-keyword\">else</span> None\n\n  <span class=\"hljs-keyword\">let</span> getCurrentRoot ctx =\n    <span class=\"hljs-keyword\">match</span> ctx.userState.TryFind(<span class=\"hljs-string\">\"rootPath\"</span>) <span class=\"hljs-keyword\">with</span>\n    | None -&gt; <span class=\"hljs-string\">\"\"</span>\n    | Some p -&gt; string p\n\n  <span class=\"hljs-keyword\">let</span> rootPath (part : string) (ctx : HttpContext) =\n    <span class=\"hljs-keyword\">let</span> root = getCurrentRoot ctx\n    { ctx <span class=\"hljs-keyword\">with</span> userState = ctx.userState.Add(<span class=\"hljs-string\">\"rootPath\"</span>, root + part) }\n    |&gt; Some\n    |&gt; async.Return\n\n  <span class=\"hljs-keyword\">let</span> subPath (part : string) (ctx : HttpContext) =\n    <span class=\"hljs-keyword\">let</span> fullPath = (getCurrentRoot ctx) + part\n    ctx\n    |&gt; optionally (fullPath = ctx.request.path)\n    |&gt; async.Return\n\n  <span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p><code>rootPath</code> allows us to specify a path prefix for <code>subPath</code> calls specified deeper in the decision tree. Because <code>rootPath</code> stores any previous root path concatenated with the supplied value, we luckily get nesting support beyond a single level. Here&#39;s a simple example, clearing up our previous <code>api</code> expression:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">module</span> App =\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">let</span> api =\n    Writers.setMimeType <span class=\"hljs-string\">\"\"\"application/json; charset=\"utf-8\";\"\"\"</span>\n    &gt;=&gt; rootPath <span class=\"hljs-string\">\"/api\"</span>\n    &gt;=&gt; choose [\n          subPath <span class=\"hljs-string\">\"\"</span> &gt;=&gt; NO_CONTENT\n          subPath <span class=\"hljs-string\">\"/users\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"\"\"{\"api\": \"users\"}\"\"\"</span>\n        ]\n\n  <span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<blockquote>\n<p>I&#39;m looking to contribute this functionality for inclusion into Suave&#39;s API and am currently <a href=\"https://github.com/SuaveIO/suave/issues/570\">awating feedback from the team</a>.</p>\n</blockquote>\n<h2 id=\"take-aways\">Take aways</h2>\n<p>.NET Core is still relatively new when compared to the mainstream .NET Framework. Because of this, Suave&#39;s support for it is still in progress (only two of seven additional official packages provide .NET Core support), and community extension of its .NET Core support is still improving (<code>Suave.AspNetCore</code> doesn&#39;t yet support all of Suave&#39;s feature set). As the community progress .NET Core support for F# and its projects, this relative newness feeling should diminish, and Suave + F# applications on the ASP.NET Core stack should be ready for production.</p>\n<p>That being said, there&#39;s no reason Suave cannot be used with ASP.NET Core in projects where 100% compatibility isn&#39;t required. Personal projects, one-off projects, etc. would, in my opinion, give you a chance to use Suave and ASP.NET Core together in a lower-risk situation.</p>\n"}