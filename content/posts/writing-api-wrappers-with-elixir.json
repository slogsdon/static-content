{"file":"posts/2013-12-08-writing-api-wrappers-with-elixir.md","type":"posts","slug":"posts/writing-api-wrappers-with-elixir","date":"2013-12-08T00:00:00.000Z","title":"Writing API Wrappers with Elixir","author":"shane","layout":"post","categories":["All Posts","Programming"],"tags":["api","elixir","functional programming","mandrill"],"alias":["/writing-api-wrappers-with-elixir/","/elixir/writing-api-wrappers-with-elixir/","/posts/elixir/writing-api-wrappers-with-elixir/"],"image":"rainy-train-window.jpeg","description":"Recently, I built an API wrapper for Mandrill. Let's walk through the steps I used to create it and see if this process might be able to help you in your next project.","content":"<p>Recently, I built an API wrapper for <a href=\"https://mandrill.com/\">Mandrill</a>. Let&#39;s walk through the steps I used to create it and see if this process might be able to help you in your next project.</p>\n<!--more-->\n<h2 id=\"installing-elixir\">Installing Elixir</h2>\n<p>If your preferred development environment does not have Elixir installed, you&#39;ll need to install it in order to continue on with the walk through. Head over to the <a href=\"http://elixir-lang.org/getting_started/1.html\">Elixir getting started page</a>, and follow their steps under section 1.1.</p>\n<p>If you&#39;ve never messed with Elixir, read the rest of the Elixir getting started page after installing Elixir. It&#39;s ok. I&#39;ll wait.</p>\n<p>Ready? Let&#39;s go.</p>\n<h2 id=\"setting-up-our-project\">Setting up our project</h2>\n<p>Developers using Elixir use <code>mix</code> for building, running, and testing their applications. What is <code>mix</code>, you ask? Well, from its <a href=\"http://elixir-lang.org/getting_started/mix/1.html\">intro page</a>:</p>\n<blockquote>\n<p>Mix is a build tool that provides tasks for creating, compiling, testing (and soon releasing) Elixir projects. Mix is inspired by the Leiningen build tool for Clojure and was written by one of its contributors.</p>\n</blockquote>\n<p>With mix, creating our project is as simple as:</p>\n<pre><code class=\"hljs language-bash\">$ mix new api_wrapper --sup\n</code></pre>\n<p>where <code>api_wrapper</code> is the name of our project. I&#39;m wanting to build a wrapper for Mandrill&#39;s API, so I&#39;ll be using <code>mandrillex</code> for my project name. If you want a reliable transactional email provider or just want to follow along, check out their <a href=\"https://mandrill.com/features/\">features page</a> and <a href=\"https://mandrill.com/signup/\">signup</a>. Psst: it&#39;s free up to 10,000 emails per month.</p>\n<h2 id=\"otp-application\">OTP application</h2>\n<p>Opening <code>lib/mandrillex.ex</code>, we see <code>mix</code> has set up a project for us that implements the bare necessities for an <a href=\"http://www.erlang.org/doc/man/application.html\">OTP application</a>, allowing our wrapper to be included in other projects easier by following the OTP design principles.</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">defmodule</span> <span class=\"hljs-title\">Mandrillex</span></span> <span class=\"hljs-keyword\">do</span>\n  <span class=\"hljs-keyword\">use</span> Application.Behaviour\n\n  <span class=\"hljs-comment\"># See http://elixir-lang.org/docs/stable/Application.Behaviour.html</span>\n  <span class=\"hljs-comment\"># for more information on OTP Applications</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">start</span></span>(_type, _args) <span class=\"hljs-keyword\">do</span>\n    Mandrillex.Supervisor.start_link\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p>We&#39;re going to leverage <a href=\"https://github.com/edgurgel/httpoison\">HTTPoison</a> for making requests to our API. Lucky for us, HTTPoison exposes a <code>HTTPoison.Base</code> module that we can embed into our module with the <code>use</code> directive.</p>\n<pre><code class=\"hljs language-elixir\">  ...\n  <span class=\"hljs-keyword\">use</span> Application.Behaviour\n  <span class=\"hljs-keyword\">use</span> HTTPoison.Base\n  ...\n</code></pre>\n<p>Now when we want to use our module elsewhere, we can simply make a call to <code>Mandrillex.start</code> to start the OTP application and listen for calls we want to send to the API.</p>\n<p>We&#39;re also going to define <code>process_url/1</code> and <code>process_response_body/1</code> to make our lives easier when using <code>HTTPoison</code>.</p>\n<pre><code class=\"hljs language-elixir\">  ...\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_url</span></span>(endpoint) <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-string\">\"https://mandrillapp.com/api/1.0/\"</span> &lt;&gt; endpoint &lt;&gt; <span class=\"hljs-string\">\".json\"</span>\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_response_body</span></span>(body) <span class=\"hljs-keyword\">do</span>\n    JSEX.decode!(body, [{<span class=\"hljs-symbol\">:labels</span>, <span class=\"hljs-symbol\">:atom</span>}])\n  <span class=\"hljs-keyword\">end</span>\n  ...\n</code></pre>\n<p>As you might be able to tell, <code>process_url/1</code> allows us to shorten our urls from <code>https://mandrillapp.com/api/1.0/users/ping.json</code> to <code>users/ping</code>, and <code>process_response_body/1</code> processes the response we receive automatically before it is returned to us.</p>\n<h2 id=\"building-out-our-wrapper\">Building out our wrapper</h2>\n<p>When compiling, Elixir will look for source files in our <code>lib</code> directory, as long as the file extensions are correct (standard is <code>*.ex</code> for files meant for compilation), and create the corresponding BEAM bytecode files. BEAM, the Erlang VM, is what handles the processes, fault-tolerance, applications, etc. for Erlang, Elixir, and other BEAM-based languages.</p>\n<p>Most developers match up module names with directories, e.g. store <code>Mandrillex</code> in <code>lib</code> and <code>Mandrillex.Users</code> in <code>lib/mandrillex</code>. We&#39;re going to follow suit and place our other module files in <code>lib/mandrillex</code>.</p>\n<p>Building out all parts of this wrapper would get fairly monotonous, so instead, we&#39;ll focus on one endpoint, <a href=\"https://mandrillapp.com/api/docs/messages.JSON.html#method-send\"><code>messages/send</code></a>.</p>\n<p>In <code>lib/mandrillex/messages.ex</code>, we&#39;re going to define our module and the function responsible for handling the <code>messages/send</code> endpoint.</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">defmodule</span> <span class=\"hljs-title\">Mandrillex</span></span>.Messages <span class=\"hljs-keyword\">do</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">send</span></span>(key, message, async, ip_pool, send_at) <span class=\"hljs-keyword\">do</span>\n    params = [\n      <span class=\"hljs-symbol\">key:</span> key,\n      <span class=\"hljs-symbol\">message:</span> message,\n      <span class=\"hljs-symbol\">async:</span> async,\n      <span class=\"hljs-symbol\">ip_pool:</span> ip_pool,\n      <span class=\"hljs-symbol\">send_at:</span> send_at\n    ]\n    Mandrillex.post(<span class=\"hljs-string\">\"messages/send\"</span>, JSEX.encode! params).body\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p>Now, we can send calls to that endpoint with this method.</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-variable\">$ </span>iex -S mix\nErlang R16B02 (erts-<span class=\"hljs-number\">5.10</span>.<span class=\"hljs-number\">3</span>) [source] [<span class=\"hljs-number\">64</span>-bit] [<span class=\"hljs-symbol\">smp:</span><span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">4</span>] [async-<span class=\"hljs-symbol\">threads:</span><span class=\"hljs-number\">10</span>] [hipe] [kernel-<span class=\"hljs-symbol\">poll:</span><span class=\"hljs-keyword\">false</span>] [dtrace]\n\nInteractive Elixir (<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">11.3</span>-dev) - press Ctrl+C to exit (type h() ENTER <span class=\"hljs-keyword\">for</span> help)\niex&gt; Mandrillex.start\n<span class=\"hljs-symbol\">:ok</span>\niex&gt; Mandrillex.Messages.send(<span class=\"hljs-string\">\"your_api_key\"</span>, [<span class=\"hljs-symbol\">text:</span> <span class=\"hljs-string\">\"testing\"</span>, <span class=\"hljs-symbol\">subject:</span> <span class=\"hljs-string\">\"test subject\"</span>, <span class=\"hljs-symbol\">from_email:</span> <span class=\"hljs-string\">\"sending email\"</span>, <span class=\"hljs-symbol\">from_name:</span> <span class=\"hljs-string\">\"sending name\"</span>, <span class=\"hljs-symbol\">to:</span> [[<span class=\"hljs-symbol\">email:</span> <span class=\"hljs-string\">\"recipient email\"</span>, <span class=\"hljs-symbol\">name:</span> <span class=\"hljs-string\">\"recipient name\"</span>, <span class=\"hljs-symbol\">type:</span> <span class=\"hljs-string\">\"to\"</span>]]], <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">nil</span>, <span class=\"hljs-keyword\">nil</span>)\n[[<span class=\"hljs-symbol\">email:</span> <span class=\"hljs-string\">\"recipient email\"</span>, <span class=\"hljs-symbol\">status:</span> <span class=\"hljs-string\">\"sent\"</span>,\n<span class=\"hljs-symbol\">_id:</span> <span class=\"hljs-string\">\"cb03be26672147dc9503ce2f90806492\"</span>, <span class=\"hljs-symbol\">reject_reason:</span> <span class=\"hljs-keyword\">nil</span>]]\n</code></pre>\n<p>Awesomesauce! We just received a successful response from the API using our newly-developed module.</p>\n<h2 id=\"streamlining-our-wrapper\">Streamlining our wrapper</h2>\n<p>I don&#39;t know about you, but since Mandrill&#39;s API calls alway need an API key passed, I would hate to have that as a parameter for all of the endpoints. Let&#39;s move that into the <code>Mandrillex</code> module:</p>\n<pre><code class=\"hljs language-elixir\">  ...\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">key</span></span> <span class=\"hljs-keyword\">do</span>\n    System.get_env(<span class=\"hljs-string\">\"MANDRILL_KEY\"</span>)\n  <span class=\"hljs-keyword\">end</span>\n  ...\n</code></pre>\n<p>and change <code>Mandrillex.Messages.send</code> to suit:</p>\n<pre><code class=\"hljs language-elixir\">  ...\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">send</span></span>(message, async, ip_pool, send_at) <span class=\"hljs-keyword\">do</span>\n    params = [\n      <span class=\"hljs-symbol\">key:</span> Mandrill.key,\n      <span class=\"hljs-symbol\">message:</span> message,\n      <span class=\"hljs-symbol\">async:</span> async,\n      <span class=\"hljs-symbol\">ip_pool:</span> ip_pool,\n      <span class=\"hljs-symbol\">send_at:</span> send_at\n    ]\n    Mandrillex.post(<span class=\"hljs-string\">\"messages/send\"</span>, JSEX.encode! params).body\n  <span class=\"hljs-keyword\">end</span>\n  ...\n</code></pre>\n<p>When starting our <code>iex</code> session, our expressions are only slightly different.</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-variable\">$ </span>MANDRILL_KEY=your_api_key iex -S mix\nErlang R16B02 (erts-<span class=\"hljs-number\">5.10</span>.<span class=\"hljs-number\">3</span>) [source] [<span class=\"hljs-number\">64</span>-bit] [<span class=\"hljs-symbol\">smp:</span><span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">4</span>] [async-<span class=\"hljs-symbol\">threads:</span><span class=\"hljs-number\">10</span>] [hipe] [kernel-<span class=\"hljs-symbol\">poll:</span><span class=\"hljs-keyword\">false</span>] [dtrace]\n\nInteractive Elixir (<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">11.3</span>-dev) - press Ctrl+C to exit (type h() ENTER <span class=\"hljs-keyword\">for</span> help)\niex&gt; Mandrillex.start\n<span class=\"hljs-symbol\">:ok</span>\niex&gt; Mandrillex.Messages.send([<span class=\"hljs-symbol\">text:</span> <span class=\"hljs-string\">\"testing\"</span>, <span class=\"hljs-symbol\">subject:</span> <span class=\"hljs-string\">\"test subject\"</span>, <span class=\"hljs-symbol\">from_email:</span> <span class=\"hljs-string\">\"sending email\"</span>, <span class=\"hljs-symbol\">from_name:</span> <span class=\"hljs-string\">\"sending name\"</span>, <span class=\"hljs-symbol\">to:</span> [[<span class=\"hljs-symbol\">email:</span> <span class=\"hljs-string\">\"recipient email\"</span>, <span class=\"hljs-symbol\">name:</span> <span class=\"hljs-string\">\"recipient name\"</span>, <span class=\"hljs-symbol\">type:</span> <span class=\"hljs-string\">\"to\"</span>]]], <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">nil</span>, <span class=\"hljs-keyword\">nil</span>)\n[[<span class=\"hljs-symbol\">email:</span> <span class=\"hljs-string\">\"recipient email\"</span>, <span class=\"hljs-symbol\">status:</span> <span class=\"hljs-string\">\"sent\"</span>,\n<span class=\"hljs-symbol\">_id:</span> <span class=\"hljs-string\">\"cb03be26672147dc9503ce2f90806492\"</span>, <span class=\"hljs-symbol\">reject_reason:</span> <span class=\"hljs-keyword\">nil</span>]]\n</code></pre>\n<p>Of course, this is only one way of introducing an environment variable. Be sure to choose the method that makes the most sense for your implementation.</p>\n<p>Moving on, I think it&#39;d be nice to have a function that makes the request for me, since I&#39;m always making <code>POST</code> requests to Mandrill&#39;s API and always JSON-encoding the request body.</p>\n<p>In the <code>Mandrillex</code> module, we&#39;ll add:</p>\n<pre><code class=\"hljs language-elixir\">  ...\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">request</span></span>(endpoint, body) <span class=\"hljs-keyword\">do</span>\n    Mandrillex.post(endpoint, JSEX.encode! body).body\n  <span class=\"hljs-keyword\">end</span>\n  ...\n</code></pre>\n<p>and update <code>Mandrillex.Messages</code> once more:</p>\n<pre><code class=\"hljs language-elixir\">  ...\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">send</span></span>(message, async, ip_pool, send_at) <span class=\"hljs-keyword\">do</span>\n    params = [\n      <span class=\"hljs-symbol\">key:</span> Mandrill.key,\n      <span class=\"hljs-symbol\">message:</span> message,\n      <span class=\"hljs-symbol\">async:</span> async,\n      <span class=\"hljs-symbol\">ip_pool:</span> ip_pool,\n      <span class=\"hljs-symbol\">send_at:</span> send_at\n    ]\n    Mandrillex.request(<span class=\"hljs-string\">\"messages/send\"</span>, params)\n  <span class=\"hljs-keyword\">end</span>\n  ...\n</code></pre>\n<p>By doing this, we are able to change our code in one place instead of many places if we were to ever change how JSON is encoded, say if we switched from <code>jsex</code> to <code>exjson</code>.</p>\n<p>If we were making more than <code>POST</code> requests, we could add a <code>method</code> parameter to <code>Mandrillex.request</code> and add other definitions with guard clauses similar to:</p>\n<pre><code class=\"hljs language-elixir\">  ...\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">request</span></span>(method, endpoint, body) <span class=\"hljs-keyword\">when</span> method == <span class=\"hljs-symbol\">:get</span> <span class=\"hljs-keyword\">do</span>\n    Mandrillex.get(endpoint, JSEX.encode! body).body\n  <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">request</span></span>(method, endpoint, body) <span class=\"hljs-keyword\">when</span> method == <span class=\"hljs-symbol\">:post</span> <span class=\"hljs-keyword\">do</span>\n    Mandrillex.post(endpoint, JSEX.encode! body).body\n  <span class=\"hljs-keyword\">end</span>\n  ...\n</code></pre>\n<p>and call it via <code>Mandrillex.request(:post, &quot;messages/send&quot;, params)</code> in <code>Mandrillex.Messages.send</code>. Alternately, we could favor a more Erlang-ish approach with pattern matching:</p>\n<pre><code class=\"hljs language-elixir\">  ...\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">request</span></span>({<span class=\"hljs-symbol\">:get</span>, endpoint, body}) <span class=\"hljs-keyword\">do</span>\n    Mandrillex.get(endpoint, JSEX.encode! body).body\n  <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">request</span></span>({<span class=\"hljs-symbol\">:post</span>, endpoint, body}) <span class=\"hljs-keyword\">do</span>\n    Mandrillex.post(endpoint, JSEX.encode! body).body\n  <span class=\"hljs-keyword\">end</span>\n  ...\n</code></pre>\n<p>and call it by wrapping the previous call&#39;s arguments as a tuple, i.e. <code>Mandrillex.request({:post, &quot;messages/send&quot;, params})</code>.</p>\n<h2 id=\"wrapping-up\">Wrapping up</h2>\n<p>We only have one endpoint covered, but our working function that allows us to make our call in a simple manner can be duplicated to handle all the other endpoints in the Mandrill API.</p>\n<p>Now it&#39;s your turn to finish up, or if you&#39;re the impatient type, head over to <a href=\"https://github.com/slogsdon/mandrillex\">slogsdon/mandrillex</a> on GitHub to look at the current version of <code>mandrillex</code> that covers the rest of the endpoints.</p>\n"}