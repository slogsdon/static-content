{"file":"posts/2017-01-11-cross-compiling-rust-applications-for-the-onion-omega2-from-macos.md","type":"posts","slug":"posts/cross-compiling-rust-applications-for-the-onion-omega2-from-macos","date":"2017-01-11T18:57:01.000Z","title":"Cross-Compiling Rust Applications for the Onion Omega2 from MacOS","tags":["rust","hardware"],"author":"shane","categories":["All Posts","Programming"],"description":"Onion's Omega2 SoC computers are a prime target for cross-compiling Rust applications, taking care to set up your environment just right for the Omega2's MIPS architecture.","content":"<p>After recently receiving the shipment for my <a href=\"https://www.kickstarter.com/projects/onion/omega2-5-iot-computer-with-wi-fi-powered-by-linux/description\">Onion Omega2 Kickstarter</a> reward, I did as any other software developer might do: I started figuring out what it would take to get software running on it. Onion&#39;s <a href=\"https://docs.onion.io/omega2-docs/\">Omega2 documentation</a> has information about installing and using Python, but while this is powerful and aids product adoption, limitations of developing directly on the device soon appear. Limited disk space, limited RAM, and limited CPU speeds will hinder development and builing of most compiled languages. To me, this sounds like a great opportunity to learn how to cross-compile applications, allowing for development and building of applications in my normal development environment. I&#39;ve been tinkering with Rust recently, so it became my language of choice for this exercise.</p>\n<p><strong>tl;dr</strong> It works.</p>\n<p><blockquote class=\"twitter-tweet\" data-conversation=\"none\" data-lang=\"en\">\n    <p lang=\"en\" dir=\"ltr\">\n        running <a href=\"https://t.co/3I3pE2WS4W\">https://t.co/3I3pE2WS4W</a>\n        and <a href=\"https://twitter.com/rustlang\">@rustlang</a> on an\n        <a href=\"https://twitter.com/OnionIoT\">@OnionIoT</a> Omega 2+, cross-compiled from MacOS\n        <a href=\"https://t.co/SdiKSNPZMZ\">pic.twitter.com/SdiKSNPZMZ</a>\n    </p>\n    &mdash; Shane Logsdon (@shanelogsdon)\n    <a href=\"https://twitter.com/shanelogsdon/status/819204972290199553\">January 11, 2017</a>\n</blockquote></p>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<h2 id=\"overview-of-steps-needed\">Overview of steps needed</h2>\n<p>Not having cross-compiled applications before, I did some research into what it takes to cross-compile:</p>\n<ul>\n<li>Know your target triple</li>\n<li>Have your application code</li>\n<li>Have a build toolchain from your target available on your host (build) system</li>\n<li>Use the target toolchain to build you application</li>\n</ul>\n<h3 id=\"what-s-a-triple-\">What&#39;s a triple?</h3>\n<p>The target triple (or triplet) is an identifier that represents three pieces of information, architecture, vendor, and operating system, and will typically follow the form:</p>\n<pre><code>&lt;architecture&gt;-&lt;vendor&gt;-&lt;operating-system&gt;\n</code></pre><h3 id=\"what-is-going-to-be-built-\">What is going to be built?</h3>\n<p>I wanted to build something in Rust that was more than a simple &quot;Hello World&quot; application that wrote to the console, so I looked to <a href=\"https://rocket.rs\">Rocket</a> to build a simple web application server. Let&#39;s take a look at the application code to see what we&#39;re working with.</p>\n<blockquote>\n<p>Scaffold the project</p>\n</blockquote>\n<pre><code>$ cargo new --bin rocket_testing\n     Created binary (application) `rocket_testing` project\n$ cd rocket_testing\n$ tree\n.\n├── Cargo.toml\n└── src\n    └── main.rs\n\n1 directory, 2 files\n</code></pre><blockquote>\n<p>Add dependencies</p>\n</blockquote>\n<pre><code class=\"hljs language-toml\"><span class=\"hljs-section\">[package]</span>\n<span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">\"rocket_testing\"</span>\n<span class=\"hljs-attr\">version</span> = <span class=\"hljs-string\">\"0.1.0\"</span>\n<span class=\"hljs-attr\">authors</span> = [<span class=\"hljs-string\">\"Shane Logsdon &lt;shane@shanelogsdon.com&gt;\"</span>]\n<span class=\"hljs-section\">\n[dependencies]</span>\n<span class=\"hljs-attr\">rocket</span> = <span class=\"hljs-string\">\"0.1.4\"</span>\n<span class=\"hljs-attr\">rocket_codegen</span> = <span class=\"hljs-string\">\"0.1.4\"</span>\n</code></pre>\n<p>Do a quick build to pull our dependencies down:</p>\n<pre><code>$ cargo build\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n Downloading rocket_codegen v0.1.4\n Downloading rocket v0.1.4\n Downloading num_cpus v1.2.1\n Downloading libc v0.2.19\n   Compiling libc v0.2.19\n   Compiling typeable v0.1.2\n   Compiling traitobject v0.0.1\n   Compiling language-tags v0.2.2\n   Compiling unicode-normalization v0.1.3\n   Compiling winapi v0.2.8\n   Compiling rustc-serialize v0.3.22\n   Compiling ansi_term v0.9.0\n   Compiling httparse v1.2.1\n   Compiling log v0.3.6\n   Compiling mime v0.2.2\n   Compiling hpack v0.2.0\n   Compiling rocket_codegen v0.1.4\nerror[E0554]: #[feature] may not be used on the stable release channel\n --&gt; /Users/shane.logsdon/.cargo/registry/src/github.com-1ecc6299db9ec823/rocket_codegen-0.1.4/build.rs:1:1\n  |\n1 | #![feature(slice_patterns)]\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nBuild failed, waiting for other jobs to finish...\nerror: Could not compile `rocket_codegen`.\n\nTo learn more, run the command again with --verbose.\n</code></pre><p>That&#39;s right. <code>rocket_codegen</code> requires some Rust nightly features at the moment, so lets use <code>rustup</code> to override our current Rust toolchain:</p>\n<pre><code>$ rustup override set nightly\ninfo: using existing install for &#39;nightly-x86_64-apple-darwin&#39;\ninfo: override toolchain for &#39;/Users/shane.logsdon/Code/rust/rocket_testing&#39; set to &#39;nightly-x86_64-apple-darwin&#39;\n\n  nightly-x86_64-apple-darwin unchanged - rustc 1.15.0-nightly (71c06a56a 2016-12-18)\n\n$ cargo build\n</code></pre><p>That time should do it if you&#39;re using a nightly release for the first time, but if your&#39;ve already had a nightly installed, you may run into this issue:</p>\n<pre><code>Build failed, waiting for other jobs to finish...\nerror: failed to run custom build command for `rocket_codegen v0.1.4`\nprocess didn&#39;t exit successfully: `/Users/shane.logsdon/Code/rust/rt/target/debug/build/rocket_codegen-0930e5f9972e7ac3/build-script-build` (exit code: 101)\n--- stderr\nError: Rocket codegen requires a newer version of rustc.\nUse `rustup update` or your preferred method to update Rust.\nInstalled version is: 2016-12-18. Minimum required: 2017-01-03.\nthread &#39;main&#39; panicked at &#39;Aborting compilation due to incompatible compiler.&#39;, /Users/shane.logsdon/.cargo/registry/src/github.com-1ecc6299db9ec823/rocket_codegen-0.1.4/build.rs:62\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n</code></pre><p>We&#39;re told that our installed version of Rust nightly is too old, and we need to install a newer one. Luckily, it&#39;s a couple of quick commands to fix:</p>\n<pre><code>$ rustup update &amp;&amp; cargo update &amp;&amp; cargo build\n# ... eventually seeing\nFinished debug [unoptimized + debuginfo] target(s) in 36.35 secs\n</code></pre><p>Once our initial build completes, we&#39;ll want to update our application code in <code>src/main.rs</code> to leverage Rocket:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#![feature(plugin)]</span>\n<span class=\"hljs-meta\">#![plugin(rocket_codegen)]</span>\n\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> rocket;\n\n<span class=\"hljs-meta\">#[get(<span class=\"hljs-meta-string\">\"/text\"</span>)]</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello</span></span>() -&gt; <span class=\"hljs-built_in\">String</span> {\n    <span class=\"hljs-built_in\">String</span>::from_str(<span class=\"hljs-string\">\"hello world\"</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    rocket::ignite()\n        .mount(<span class=\"hljs-string\">\"/\"</span>, routes![hello])\n        .launch();\n}\n</code></pre>\n<p>We can then build again and test our application (Rocket listens on <a href=\"http://localhost:8000/\"><code>http://localhost:8000/</code></a> by default). At this point we have a working application for our host system, which in my case has the triple <code>x86_64-apple-darwin</code>.</p>\n<h2 id=\"where-do-we-find-our-target-build-toolchain-\">Where do we find our target build toolchain?</h2>\n<p>Since we now have a working application, we need to figure out how to get our application cross-compiled. Some googling resulted in some useful information specifically for Rust. <a href=\"https://github.com/japaric/rust-cross\"><code>rust-cross</code></a> has some excellent information on this process, but since I didn&#39;t even know what the Omega2&#39;s architecture was, I figured I better find out. I booted up my Omega2+ and <code>ssh</code>&#39;d into it:</p>\n<pre><code>$ ssh root@192.168.3.1\nroot@192.168.3.1&#39;s password:\n\n\nBusyBox v1.25.1 () built-in shell (ash)\n\n   ____       _             ____\n  / __ \\___  (_)__  ___    / __ \\__ _  ___ ___ ____ _\n / /_/ / _ \\/ / _ \\/ _ \\  / /_/ /  &#39; \\/ -_) _ `/ _ `/\n \\____/_//_/_/\\___/_//_/  \\____/_/_/_/\\__/\\_, /\\_,_/\n W H A T  W I L L  Y O U  I N V E N T ? /___/\n -----------------------------------------------------\n   Ω-ware: 0.1.7 b139\n -----------------------------------------------------\nroot@Omega-708F:~# uname -a\nLinux Omega-708F 4.4.39 #0 Thu Dec 29 17:07:01 2016 mips GNU/Linux\nroot@Omega-708F:~#\n</code></pre><p>That told me enough to start my search for the reuired build chain. At this point, I went to <code>rustup</code> to see what architecture&#39;s it supported.</p>\n<blockquote>\n<p>Side note: <code>rustup</code> not only manages Rust stable, beta, and nightly installations but also manages Rust toolchains for all the architectures Rust supports!</p>\n</blockquote>\n<pre><code>$ rustup target list\naarch64-apple-ios\naarch64-linux-android\naarch64-unknown-linux-gnu\narm-linux-androideabi\narm-unknown-linux-gnueabi\narm-unknown-linux-gnueabihf\narm-unknown-linux-musleabi\narm-unknown-linux-musleabihf\narmv7-apple-ios\narmv7-linux-androideabi\narmv7-unknown-linux-gnueabihf\narmv7-unknown-linux-musleabihf\narmv7s-apple-ios\nasmjs-unknown-emscripten\ni386-apple-ios\ni586-pc-windows-msvc\ni586-unknown-linux-gnu\ni686-apple-darwin\ni686-linux-android\ni686-pc-windows-gnu\ni686-pc-windows-msvc\ni686-unknown-freebsd\ni686-unknown-linux-gnu\ni686-unknown-linux-musl\nmips-unknown-linux-gnu\nmips-unknown-linux-musl\nmips64-unknown-linux-gnuabi64\nmips64el-unknown-linux-gnuabi64\nmipsel-unknown-linux-gnu\nmipsel-unknown-linux-musl\npowerpc-unknown-linux-gnu\npowerpc64-unknown-linux-gnu\npowerpc64le-unknown-linux-gnu\ns390x-unknown-linux-gnu\nwasm32-unknown-emscripten\nx86_64-apple-darwin (default)\nx86_64-apple-ios\nx86_64-pc-windows-gnu\nx86_64-pc-windows-msvc\nx86_64-rumprun-netbsd\nx86_64-unknown-freebsd\nx86_64-unknown-linux-gnu\nx86_64-unknown-linux-musl\nx86_64-unknown-netbsd\n</code></pre><p><code>rustup</code> is showing 6 <code>mips</code>-related targets. We&#39;ve narrowed it down some, but we still don&#39;t know the exact one we require or if Rust/<code>rustup</code> even support it. I took to looking through the <a href=\"https://community.onion.io/category/2/omega-talk\">community forums</a> searching for <code>mips</code> and began to see others looking to do some cross-compilation of code. Across a few separate thread, I put together some information:</p>\n<ul>\n<li>The Omega2&#39;s use the MediaTek MT7688 SoC (system on chip) which include a MIPS&reg; 24KEc&trade; CPU</li>\n<li>The Omega2 OS is based on the <a href=\"https://lede-project.org/\">LEDE Project</a>, a fork of the OS behind OpenWrt</li>\n<li>OpenWrt/LEDE have SDKs for building the OS firmware images which include the build toolchain</li>\n</ul>\n<p>Eventually, I found a few forum threads with references to <a href=\"https://github.com/WereCatf/source\">WereCatf&#39;s repository</a>, a GitHub fork of the LEDE Project&#39;s SDK with the necessary changes to add the Omega2 and Omega2+ build DTS (device tree source) configurations add a few other fixes. With the SDK, we have everything we need to build our application for the Omega2, but now the SDK needs to be built since we only have the source and nothing specific for the Omega2.</p>\n<h2 id=\"building-the-build-toolchain\">Building the build toolchain</h2>\n<p>Luckily, the build process for the LEDE SDK is the same as the OpenWrt SDK, and at least for MacOS, the build requirements are the same. I&#39;ve included OpenWrt&#39;s instructions for MacOS 10.11 here, but other versions and OS&#39;s can be found on <a href=\"https://wiki.openwrt.org/doc/howto/buildroot.exigence.macosx\">their documentation site</a>.</p>\n<blockquote>\n<ol>\n<li><p>Install Xcode or at least Xcode command line tools from the MacOSX App Store</p>\n</li>\n<li><p>Install <a href=\"http://brew.sh/\">Homebrew</a>.</p>\n</li>\n<li><p>Add duplicates repository to homebrew for grep formulae:</p>\n<pre><code>brew tap homebrew/dupes\n</code></pre></li>\n<li>Install additional formulae:<pre><code>brew install coreutils findutils gawk gnu-getopt gnu-tar grep wget quilt xz\n</code></pre></li>\n<li><code>gnu-getopt</code> is keg-only, so force linking it:<pre><code>brew ln gnu-getopt --force\n</code></pre></li>\n<li>To get rid of &quot;date illegal option&quot; you can add to your <code>.bash_profile</code> (wasn&#39;t required for me):<pre><code>PATH=&quot;/usr/local/opt/coreutils/libexec/gnubin:$PATH&quot;\n</code></pre></li>\n<li>OS X by default comes with a case-insensitive filesystem. OpenWrt won&#39;t build on that. As a workaround, create a (Sparse) case-sensitive disk-image that you then mount in Finder and use as build directory:<pre><code>hdiutil create -size 20g -type SPARSE -fs &quot;Case-sensitive HFS+&quot; -volname OpenWrt OpenWrt.sparseimage\nhdiutil attach OpenWrt.sparseimage\n</code></pre></li>\n<li>Change to your newly created and mounted disk image:<pre><code>/Volumes/OpenWrt\n</code></pre></li>\n<li>Now proceed normally (<code>git clone…</code>)</li>\n</ol>\n</blockquote>\n<p>If, like me, you have no idea how to &quot;proceed normally&quot;, let me fill you in. We&#39;re going to obtain the source, configure it for our needs, and build it.</p>\n<h3 id=\"getting-the-source\">Getting the source</h3>\n<p>This one&#39;s going to be quick and simple using <code>git</code>:</p>\n<pre><code>$ git clone https://github.com/WereCatf/source\n$ cd source\n</code></pre><h3 id=\"configuring-the-sdk\">Configuring the SDK</h3>\n<p>Since OpenWrt/LEDE can be used on multiple architectures, we need to configure the SDK to be compatible with the Omega2. There are a few ways to do this, but we&#39;ll use <code>make menuconfig</code> here for a <code>ncurses</code>-based configuration process.</p>\n<blockquote>\n<p>Tip: The menus use <code>up</code> and <code>down</code> keys to move between options, <code>left</code> and <code>right</code> to move between commands for a given screen (located at the bottom), <code>enter</code> to select a command (usually &quot;Select&quot;, &quot;Exit&quot;, and &quot;Save&quot;), and <code>space</code> to enable/select an option.</p>\n</blockquote>\n<p>The three items we need to set (with desired values) are:</p>\n<ul>\n<li>Target System: <code>MediaTek Ralink MIPS</code></li>\n<li>Subtarget: <code>MT7688 based boards</code></li>\n<li>Target Profile: <code>Onion Omega2</code> or <code>Onion Omega2+</code></li>\n</ul>\n<blockquote>\n<p>Note: I also enabled the <code>Build the LEDE SDK</code> and <code>Package the LEDE-based Toolchain</code> options, but I have no idea if this affects the end result. They sounded important/useful. Having those enabled allowed for me to use the toolchain later, but I didn&#39;t have the desire to go back to check if it was necessary.</p>\n</blockquote>\n<p>Don&#39;t forget to save the configuration or else the SDK will build with its defaults.</p>\n<h3 id=\"build-the-toolchain\">Build the toolchain</h3>\n<p>Building the SDK&#39;s toolchain is another easy and simple process, but it takes some time to complete.</p>\n<pre><code>$ make toolchain/install\n</code></pre><p>Let your system do its thing for a while, and do something enjoyable. You can also wait, wait, wait, wait. The good news to take away here is that this only needs to be done once per architecture for your build environment, so if you only use this SDK for the Omega2, it will only need to be built again if you want the build toolchain on another system Docker, etc. Eventually, it should finish, leaving your toolchain within the SDK directory:</p>\n<pre><code>$ tree -L 1 staging_dir/toolchain-mipsel_24kc_gcc-5.4.0_musl-1.1.15\nstaging_dir/toolchain-mipsel_24kc_gcc-5.4.0_musl-1.1.15\n├── bin\n├── include\n├── info.mk\n├── initial\n├── lib\n├── lib32 -&gt; lib\n├── lib64 -&gt; lib\n├── libexec\n├── mipsel-openwrt-linux -&gt; mipsel-openwrt-linux-musl\n├── mipsel-openwrt-linux-musl\n├── share\n├── stamp\n└── usr\n\n12 directories, 1 file\n</code></pre><p>Cool. From <code>rustup</code>&#39;s possible <code>mips</code> targets (pasted below), we may be able to choose one finally:</p>\n<pre><code>mips-unknown-linux-gnu\nmips-unknown-linux-musl\nmips64-unknown-linux-gnuabi64\nmips64el-unknown-linux-gnuabi64\nmipsel-unknown-linux-gnu\nmipsel-unknown-linux-musl\n</code></pre><p>Our toolchain seems to be for the <code>mipsel</code> architecture and is compatible with <code>musl</code>, a <code>libc</code> compatible library for compiling statically-linked applications, so the <code>mipsel-unknown-linux-musl</code> Rust toolchain could work for us. Attempting to run <code>cargo compile</code> at this point will result in a big wall of text and the following error:</p>\n<pre><code>$ cd project/directory\n$ rustup target add mipsel-unknown-linux-musl\n$ cargo build --target mipsel-unknown-linux-musl\n$ ... big wall of text\nld: unknown option: --as-needed\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n\n\nerror: aborting due to previous error\n\nerror: Could not compile `rocket_testing`.\n</code></pre><p>This is due to my host system&#39;s linker (<code>/usr/bin/cc</code>) being used during the build but being incompatible with the <code>mipsel</code> architecture. Being completely new to cross-compilation, I had no idea how to use the correct build toolchain. Luckily, Rust ecosystem developers love documentation, and Cargo&#39;s documentation includes a page on <a href=\"http://doc.crates.io/config.html\">configuration</a> that gave me a hint in the <code>target.$triple.linker</code> configuration key:</p>\n<pre><code>[target.mipsel-unknown-linux-musl]\nlinker = &quot;/Volumes/OpenWrt/lede/staging_dir/toolchain-mipsel_24kc_gcc-5.4.0_musl-1.1.15/bin/mipsel-openwrt-linux-musl-gcc&quot;\n</code></pre><p>Adding that to my <code>Cargo.toml</code> file &hellip; didn&#39;t help. Turns out that target configuration options are ignored in a project&#39;s <code>Cargo.toml</code> and need to be in a <code>.cargo/config</code> (also covered by the Cargo documentation page on configuration). The resulting directory structure with the added <code>.cargo/config</code> file:</p>\n<pre><code>$ tree -a -L 2\n.\n├── .cargo\n│   └── config\n├── .gitignore\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── main.rs\n└── target\n    ├── debug\n    ├── mipsel-unknown-linux-musl\n    └── release\n\n6 directories, 5 files\n</code></pre><p>Running <code>cargo build</code> again bears some results:</p>\n<pre><code>$ cargo build --target=mipsel-unknown-linux-musl\n   Compiling rocket_testing v0.1.0 (file:///Users/shane.logsdon/Code/rust/rocket-testing)\n    Finished debug [unoptimized + debuginfo] target(s) in 2.27 secs\n</code></pre><p>It&#39;s built, but does it run? Let&#39;s ship it over to the Omega2+ to test:</p>\n<pre><code>$ cargo build --target=mipsel-unknown-linux-musl --release\n# ... build log\n    Finished release [optimized] target(s) in 305.51 secs\n$ scp target/mipsel-unknown-linux-musl/release/rocket_testing root@192.168.3.1:/root/\nrocket_testing                                        100%   17MB  93.1KB/s   03:04\n</code></pre><p>That uploaded the application&#39;s release binary to the root user&#39;s <code>$HOME</code> directory and can be ran with <code>cd /root &amp;&amp; ./rocket_testing</code>:</p>\n<p><blockquote class=\"twitter-tweet\" data-conversation=\"none\" data-lang=\"en\">\n    <p lang=\"en\" dir=\"ltr\">\n        running <a href=\"https://t.co/3I3pE2WS4W\">https://t.co/3I3pE2WS4W</a>\n        and <a href=\"https://twitter.com/rustlang\">@rustlang</a> on an\n        <a href=\"https://twitter.com/OnionIoT\">@OnionIoT</a> Omega 2+, cross-compiled from MacOS\n        <a href=\"https://t.co/SdiKSNPZMZ\">pic.twitter.com/SdiKSNPZMZ</a>\n    </p>\n    &mdash; Shane Logsdon (@shanelogsdon)\n    <a href=\"https://twitter.com/shanelogsdon/status/819204972290199553\">January 11, 2017</a>\n</blockquote></p>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<h2 id=\"departing-notes\">Departing notes</h2>\n<p>I don&#39;t believe this is perfect, but it will get the majority of applications compiled for the Omega2. I&#39;ve already ran into an issue when using <a href=\"http://diesel.rs\">Diesel</a> and Postgres in a project, but I feel like it only needs some tweaking to get it going. This post will be updated once I figure that bit out.</p>\n<p>The Omega2 isn&#39;t the only build target available for Rust, as shown by <code>rustup target list</code>, and is accompanied by <code>arm</code> (e.g. Raspberry Pi Zero), <code>armv7</code> (e.g. Raspberry Pi 2 Model B), and <code>wasm32</code> (WebAssembly, currently available in Chrome Canary and Firefox Nightly). Cross-compilation could allow you to target all these platforms with the same code base, useful if you&#39;re building an Internet of Things <a href=\"http://www.welivesecurity.com/2016/10/24/10-things-know-october-21-iot-ddos-attacks/\"><del>botnet</del></a> application and want to use multiple device types, or it could allow you to ship compiled binaries for your customers&#39;s various production environments using a single build environment configuration.</p>\n"}