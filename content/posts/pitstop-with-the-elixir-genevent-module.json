{"file":"posts/2015-08-15-pitstop-with-the-elixir-genevent-module.md","type":"posts","slug":"posts/pitstop-with-the-elixir-genevent-module","date":"2015-08-16T00:00:00.000Z","title":"Pitstop with the Elixir GenEvent Module","author":"shane","layout":"post","categories":["All Posts","Programming"],"tags":["elixir","functional programming","genevent"],"alias":["/pitstop-with-the-elixir-genevent-module/"],"image":"whitewater.jpeg","description":"Take a break with me as I make a pitstop the Elixir GenEvent module, seeing what it can offer in a real life project.","content":"<p>Wanting to learn more about WebSockets, I decided to create an easy to use, drop-in tool for Elixir&#39;s Plug library that adds WebSocket support for those using Plug and Cowboy (<a href=\"https://github.com/slogsdon/plug-web-socket\">plug-web-socket</a>), the only officially supported web server. One important piece of the puzzle I needed to align required an interface for users to broadcast and subscribe to events. What&#39;s the point of a WebSocket connection anyways of the server can&#39;t react to events on the client or even elsewhere on the server?</p>\n<p>For that task, my first thoughts went to GenServers. I probably could have made a GenServer to do the necessary work, however I found that GenEvent provided a more focused abstraction around what I wanted accomplished. Let&#39;s walk through a basic usage of Elixir&#39;s GenEvent module, stepping through the end result of <a href=\"https://github.com/slogsdon/plug-web-socket/blob/master/lib/web_socket/events.ex\">my library&#39;s event notification layer</a>.</p>\n<!--more-->\n<blockquote>\n<p><strong>Note:</strong> I&#39;m going to be commenting through the module I created similar to that of a literate program, talking to parts of the module as it&#39;s laid out.</p>\n</blockquote>\n<h2 id=\"getting-started\">Getting Started</h2>\n<p>Here&#39;s the easy bit. I&#39;ve created the module and used the Elixir <code>GenEvent</code> module, creating a set of base case <code>:gen_event</code> callback functions.</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">defmodule</span> <span class=\"hljs-title\">WebSocket</span></span>.Events <span class=\"hljs-keyword\">do</span>\n  <span class=\"hljs-keyword\">use</span> GenEvent\n</code></pre>\n<p>Now, I only need to implement the callback functions that I need. Hooray for removal of extra boilerplate code!</p>\n<h2 id=\"starting-the-process\">Starting the Process</h2>\n<p>Next up, I define a <code>start_link/1</code> function, useful for adding the <code>WebSocket.Events</code> module to a supervisor as a worker child. The <code>ref</code> is an atom-based name that will be used throughout the application, and for now, this is the function atom used in the project&#39;s routing macro. I know there are some issues here, but the project as a whole mess of improvements to be made.</p>\n<pre><code class=\"hljs language-elixir\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">start_link</span></span>(ref) <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-keyword\">case</span> GenEvent.start_link(<span class=\"hljs-symbol\">name:</span> ref) <span class=\"hljs-keyword\">do</span>\n      {<span class=\"hljs-symbol\">:ok</span>, pid} -&gt;\n        GenEvent.add_handler(ref, __MODULE_<span class=\"hljs-number\">_</span>, [])\n        {<span class=\"hljs-symbol\">:ok</span>, pid}\n      {<span class=\"hljs-symbol\">:error</span>, {<span class=\"hljs-symbol\">:already_started</span>, pid}} -&gt;\n        {<span class=\"hljs-symbol\">:ok</span>, pid}\n      otherwise -&gt;\n        otherwise\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p>One line that I want to touch on is the following:</p>\n<pre><code class=\"hljs language-elixir\">        GenEvent.add_handler(ref, __MODULE__, [])\n</code></pre>\n<p>The normal route for <code>GenEvent</code> is to have a set of handler modules that are added and removed from an event manager. Here, I&#39;m creating the event manager with <code>GenEvent.start_link/1</code> and immediately adding the <code>WebSocket.Events</code> module as a handler. Since a module can only be added as a <code>GenEvent</code> handler once per manager <code>ref</code>, the above line is only included in the case where the manager is started and not when the manager is already running. One of my goals is to find a nice workaround for this limitation in order to remove the need to manage my own set of PIDs later on in the module.</p>\n<p><code>start_link/1</code> is called in the <a href=\"https://github.com/slogsdon/plug-web-socket/blob/master/lib/web_socket/cowboy/handler.ex#L33-L36\"><code>init/3</code> callback of my Cowboy WebSocket handler</a> which itself is called when a client connects to a WebSocket endpoint for the first time to upgrade its connection. The hit of starting the process is only on the first client to a specific endpoint, so the <code>GenEvent</code> manager process is only running when a endpoint is actually used.</p>\n<h2 id=\"the-public-api\">The Public API</h2>\n<p>Next up is the public API for the module. These are the bits a developer would use when developing her own application. In these functions, we continue to expect a <code>ref</code> to be passed in order to notify the correct <code>GenEvent</code> manager, which in turn notifies the correct <code>WebSocket.Events</code> handler. A developer always has the option of passing a PID here, but it&#39;s often easier to pass an atom since this removes the need to maintain the manager&#39;s PID somewhere in state.</p>\n<pre><code class=\"hljs language-elixir\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">join</span></span>(ref, pid) <span class=\"hljs-keyword\">do</span>\n    GenEvent.notify(ref, {<span class=\"hljs-symbol\">:add_client</span>, pid})\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">leave</span></span>(ref, pid) <span class=\"hljs-keyword\">do</span>\n    GenEvent.notify(ref, {<span class=\"hljs-symbol\">:remove_client</span>, pid})\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">broadcast</span></span>(ref, event, originator) <span class=\"hljs-keyword\">do</span>\n    GenEvent.notify(ref, {<span class=\"hljs-symbol\">:send</span>, event, originator})\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">broadcast!</span></span>(ref, event) <span class=\"hljs-keyword\">do</span>\n    broadcast(ref, event, <span class=\"hljs-keyword\">nil</span>)\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">stop</span></span>(ref) <span class=\"hljs-keyword\">do</span>\n    GenEvent.stop(ref)\n  <span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p>One improvement that should be able to be made here is making the <code>pid</code> and <code>originator</code> arguments optional. More often than not, these will be called from/in the subscribing/subscribed process itself, so it should be able to default to <code>self</code> since <code>GenEvent.notify/2</code> will do the actual message passing to the handler.</p>\n<h2 id=\"-genevent-callbacks\"><code>GenEvent</code> Callbacks</h2>\n<p>The real meat and potatoes of this module are the <code>GenEvent</code> callback functions. These manage subscribers for the handler and propagate the event across the list of subscribers.</p>\n<pre><code class=\"hljs language-elixir\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">handle_event</span></span>({<span class=\"hljs-symbol\">:add_client</span>, pid}, clients) <span class=\"hljs-keyword\">do</span>\n    {<span class=\"hljs-symbol\">:ok</span>, [pid|clients]}\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">handle_event</span></span>({<span class=\"hljs-symbol\">:remove_client</span>, pid}, clients) <span class=\"hljs-keyword\">do</span>\n    {<span class=\"hljs-symbol\">:ok</span>, clients |&gt; Enum.filter(&amp;(&amp;<span class=\"hljs-number\">1</span> != pid))}\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">handle_event</span></span>({<span class=\"hljs-symbol\">:send</span>, event, originator}, clients) <span class=\"hljs-keyword\">do</span>\n    spawn <span class=\"hljs-keyword\">fn</span> -&gt;\n      clients |&gt; Enum.map(&amp;(maybe_send(&amp;<span class=\"hljs-number\">1</span>, originator, event)))\n    <span class=\"hljs-keyword\">end</span>\n    {<span class=\"hljs-symbol\">:ok</span>, clients}\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">defp</span> <span class=\"hljs-title\">maybe_send</span></span>(client, originator, event) <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-keyword\">unless</span> client == originator <span class=\"hljs-keyword\">do</span>\n      send client, event\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p>This concludes the actual contents of the <code>WebSocket.Events</code> module.</p>\n<p>If I can find a nice work around for the limitation above, most of this would be simplified. The state (<code>clients</code>) would then be a single client, and there would only be a need for the last definition of <code>handle_event/2</code> with some modifications:</p>\n<pre><code class=\"hljs language-elixir\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">handle_event</span></span>({<span class=\"hljs-symbol\">:send</span>, _event, client}, client}, <span class=\"hljs-symbol\">do:</span> {<span class=\"hljs-symbol\">:ok</span>, client}\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">handle_event</span></span>({<span class=\"hljs-symbol\">:send</span>, event, _originator}, client} <span class=\"hljs-keyword\">do</span>\n    send client, event\n  <span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p>Wouldn&#39;t that be nice? I think so!</p>\n"}