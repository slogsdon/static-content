{"file":"posts/2016-12-23-exploring-fsharp-with-dotnet-core-and-kestrel.md","type":"posts","slug":"posts/exploring-fsharp-with-dotnet-core-and-kestrel","date":"2016-12-23T00:00:00.000Z","title":"Exploring F# with .NET Core and Kestrel","tags":["functional programming",".net","fsharp"],"author":"shane","categories":["All Posts","Programming"],"description":"While not the primary focus of Microsoft's efforts, F# makes for an excellent language choice for applications targeting .NET Core.","modified":"2017-01-22T00:00:00.000Z","content":"<p>Interested in functional programming, I&#39;ve always felt F# would be a good tool to have at my disposal considering there are a plethora of .NET-focused development companies around my area. Even though Microsoft focuses its efforts on C# , F# is an excellent and viable alternative for developing applications that target the .NET Core platform, opening hosting options to more than just Windows.</p>\n<h2 id=\"basics\">Basics</h2>\n<p>F# support is exposed directly in the new <code>dotnet</code> CLI tool through the <code>--lang</code> option flag which currently supports both C# and F#. Using the <code>dotnet new</code> command, we can scaffold a barebones project to dip our feet in F# and .NET Core:</p>\n<pre><code class=\"hljs language-bash\">mkdir hello\n<span class=\"hljs-built_in\">cd</span> hello\ndotnet new --lang fsharp\n</code></pre>\n<p>Once we have our project ready, seeing the result of our efforts is as easy as restoring the project&#39;s dependencies with <code>dotnet restore</code> and running <code>dotnet run</code> which also causes <code>dotnet build</code> to run:</p>\n<blockquote>\n<p>Restoring dependencies</p>\n</blockquote>\n<pre><code>$ dotnet restore\nlog  : Restoring packages for /Users/shane.logsdon/Code/fsharp/hello/project.json...\nlog  : Restoring packages for tool &#39;dotnet-compile-fsc&#39; in /Users/shane.logsdon/Code/fsharp/hello/project.json...\nlog  : Writing lock file to disk. Path: /Users/shane.logsdon/Code/fsharp/hello/project.lock.json\nlog  : /Users/shane.logsdon/Code/fsharp/hello/project.json\nlog  : Restore completed in 3702ms.\n</code></pre><blockquote>\n<p>Building and running the project</p>\n</blockquote>\n<pre><code>$ dotnet run\nProject hello (.NETCoreApp,Version=v1.1) will be compiled because expected outputs are missing\nCompiling hello for .NETCoreApp,Version=v1.1\n\nCompilation succeeded.\n    0 Warning(s)\n    0 Error(s)\n\nTime elapsed 00:00:06.0706876\n\n\nHello World!\n</code></pre><p>Rerunning the project without modifying the files will cause the built file to be re-executed without compiling:</p>\n<pre><code>$ dotnet run\nProject hello (.NETCoreApp,Version=v1.1) was previously compiled. Skipping compilation.\nHello World!\n</code></pre><p>Be sure to note above that <code>dotnet new</code> creates the files in the current working directory. Let&#39;s take a look at what comes of that command:</p>\n<pre><code class=\"hljs language-bash\">$ tree\n.\n├── Program.fs\n└── project.json\n\n0 directories, 2 files\n</code></pre>\n<p>There&#39;s not a lot going on there, so diving into each file won&#39;t take long.</p>\n<h3 id=\"-program-fs-\"><code>Program.fs</code></h3>\n<p>The sole code file contains a simple &quot;Hello World&quot; snippet for getting you going:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-comment\">// Learn more about F# at http://fsharp.org</span>\n\n<span class=\"hljs-keyword\">open</span> System\n\n<span class=\"hljs-meta\">[&lt;EntryPoint&gt;]</span>\n<span class=\"hljs-keyword\">let</span> main argv =\n    printfn <span class=\"hljs-string\">\"Hello World!\"</span>\n    <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// return an integer exit code</span>\n</code></pre>\n<p>As alluded to in the file, Microsoft doesn&#39;t spend too much time with detailed example, instead delegating any explanation of F# to <a href=\"http://fsharp.org\">fsharp.org</a>.</p>\n<h3 id=\"-project-json-\"><code>project.json</code></h3>\n<p>The project&#39;s configuration file is pretty standard for .NET Core applications (at least until Microsoft transitions to a MSBuild file once again), but there are a few F# specific items that are necessary to have everything hooked up properly:</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">\"buildOptions\"</span>: {\n    <span class=\"hljs-attr\">\"debugType\"</span>: <span class=\"hljs-string\">\"portable\"</span>,\n    <span class=\"hljs-attr\">\"emitEntryPoint\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">\"compilerName\"</span>: <span class=\"hljs-string\">\"fsc\"</span>,\n    <span class=\"hljs-attr\">\"compile\"</span>: {\n      <span class=\"hljs-attr\">\"includeFiles\"</span>: [\n        <span class=\"hljs-string\">\"Program.fs\"</span>\n      ]\n    }\n  },\n  <span class=\"hljs-attr\">\"tools\"</span>: {\n    <span class=\"hljs-attr\">\"dotnet-compile-fsc\"</span>: <span class=\"hljs-string\">\"1.0.0-preview2.1-*\"</span>\n  }\n}\n</code></pre>\n<p>Important point #1 is the inclusion of the F# compiler (<code>fsc</code>) as a part of the tools section. This will bring in the compiler along with other NuGet packages when running <code>dotnet restore</code> on the project.</p>\n<p>Important point #2 to note are the additional build options to make use of the F# compiler, specifically the <code>buildOptions.compilerName</code> and <code>buildOptions.compile</code> properties. The <code>compilerName</code> property needs to be set since the <code>dotnet</code> CLI tool defaults to compiling C#. The <code>compile</code> property (and <code>compile.includeFiles</code>) needs to be set to tell the compiler which files are apart of the project and which order they should be loaded.</p>\n<h2 id=\"extended-scaffolding\">Extended Scaffolding</h2>\n<p>When looking for scaffolded projects more in line with what is offered through Visual Studio, <code>dotnet new</code> isn&#39;t going to cut it, and Visual Studio Code (and similar editors) aren&#39;t going to have that functionality baked in by default. Luckily, there is a project scaffolding tool called <a href=\"http://yeoman.io/\">Yeoman</a> that has been adopted and used pretty much since the inception of .NET Core through the <a href=\"https://github.com/omnisharp/generator-aspnet\"><code>generator-aspnet</code> add-on</a>, an open source project under the <a href=\"https://github.com/OmniSharp\">OmniSharp organization on Github</a>. Microsoft itself even has documentation around <a href=\"https://docs.microsoft.com/en-us/aspnet/core/client-side/yeoman\">building projects with Yeoman</a> on its documentation site.</p>\n<p>Installation is easy once Node.js and NPM are available:</p>\n<pre><code>npm install -g yo generator-aspnet\n</code></pre><p>and invoking the Yeoman generator is as simple as running <code>yo aspnet</code> and answering some questions:</p>\n<pre><code>$ yo aspnet\n\n     _-----_     ╭──────────────────────────╮\n    |       |    │      Welcome to the      │\n    |--(o)--|    │  marvellous ASP.NET Core │\n   `---------´   │        generator!        │\n    ( _´U`_ )    ╰──────────────────────────╯\n    /___A___\\   /\n     |  ~  |\n   __&#39;.___.&#39;__\n ´   `  |° ´ Y `\n\n? What type of application do you want to create?\n  Web Application Basic [without Membership and Authorization] (F#)\n  Web API Application\n❯ Web API Application (F#)\n  Nancy ASP.NET Application\n  Class Library\n  Class Library (F#)\n  Unit test project (xUnit.net)\n(Move up and down to reveal more choices)\n</code></pre><p><code>generator-aspnet</code> contains both C# and F# projects, with the F# ones denoted in the selection interface with a suffix of <code>(F#)</code>, and all project templates contained within the generator are designed for .NET Core. There is another generator for F# projects, <code>generator-fsharp</code>, but those projects are primarily focused on targeting .NET Framework, not .NET Core.</p>\n<p>A project created with <code>yo aspnet</code> will resemble a standard project layout much more closely, and those based on ASP.NET will have the same <code>Program</code> and <code>Startup</code> classes that their C#-based brethren contain.</p>\n<pre><code>$ tree ProjectName\ntree\n.\n├── Controllers.fs\n├── Dockerfile\n├── Program.fs\n├── Properties\n│   └── launchSettings.json\n├── README.md\n├── Startup.fs\n├── appsettings.json\n├── project.json\n├── web.config\n└── wwwroot\n\n2 directories, 9 files\n</code></pre><p>More than a simple &quot;Hello World&quot; example, a project spun up with the ASP.NET Yeoman generator will get you going with the cross-platform Kestrel server that comes bundled with ASP.NET Core. This will allow for a consistent development and deployment experience across all .NET Core supported platforms, Windows, MacOS, and Linux.</p>\n<p>Running the new ASP.NET project will use the same <code>dotnet run</code> command but will add some new output during the program&#39;s execution:</p>\n<pre><code>$ dotnet run\nProject ProjectName (.NETCoreApp,Version=v1.0) will be compiled because expected outputs are missing\nCompiling ProjectName for .NETCoreApp,Version=v1.0\n\nCompilation succeeded.\n    0 Warning(s)\n    0 Error(s)\n\nTime elapsed 00:00:08.9821561\n\n\nHosting environment: Production\nContent root path: /Users/shane.logsdon/Code/fsharp/ProjectName\nNow listening on: http://localhost:5000\nApplication started. Press Ctrl+C to shut down.\n</code></pre><p>When hitting the project&#39;s HTTP endpoint (which defaults to <code>http://localhost:5000</code>), you&#39;ll see the <code>Server: Kestrel</code> header being sent in the response:</p>\n<pre><code>$ curl -i http://localhost:5000/api/values\nHTTP/1.1 200 OK\nDate: Fri, 23 Dec 2016 21:45:45 GMT\nTransfer-Encoding: chunked\nContent-Type: application/json; charset=utf-8\nServer: Kestrel\n\n[&quot;value1&quot;,&quot;value2&quot;]\n</code></pre><p>There should also be some new logging messages in the terminal with the application running:</p>\n<pre><code>info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]\n      Request starting HTTP/1.1 GET http://localhost:5000/api/values\ninfo: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[1]\n      Executing action method ProjectName.Controllers.ValuesController.Get (ProjectName) with arguments () - ModelState is Valid\ninfo: Microsoft.AspNetCore.Mvc.Internal.ObjectResultExecutor[1]\n      Executing ObjectResult, writing value Microsoft.AspNetCore.Mvc.ControllerContext.\ninfo: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[2]\n      Executed action ProjectName.Controllers.ValuesController.Get (ProjectName) in 255.1666ms\ninfo: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]\n      Request finished in 294.6313ms 200 application/json; charset=utf-8\n</code></pre><p>I&#39;ll count getting this far as a success, even though there hasn&#39;t been enough code added to the project. That being said, I still need to take a further dive into both F# and .NET Core, and being a web-focused developer, I will most likely use ASP.NET to explore both of them. What I don&#39;t currently like is how the types in the project are too object-oriented. Here&#39;s the <code>ValuesController</code> from our project:</p>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">namespace</span> ProjectName.Controllers\n\n<span class=\"hljs-keyword\">open</span> System\n<span class=\"hljs-keyword\">open</span> System.Collections.Generic\n<span class=\"hljs-keyword\">open</span> System.Linq\n<span class=\"hljs-keyword\">open</span> System.Threading.Tasks\n<span class=\"hljs-keyword\">open</span> Microsoft.AspNetCore.Mvc\n\n\n<span class=\"hljs-meta\">[&lt;Route(\"api/[controller]\")&gt;]</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">ValuesController</span></span>() =\n    <span class=\"hljs-keyword\">inherit</span> Controller()\n\n    <span class=\"hljs-comment\">// GET api/values</span>\n    <span class=\"hljs-meta\">[&lt;HttpGet&gt;]</span>\n    <span class=\"hljs-keyword\">member</span> this.Get() = [| <span class=\"hljs-string\">\"value1\"</span>; <span class=\"hljs-string\">\"value2\"</span> |]\n\n    <span class=\"hljs-comment\">// GET api/values/5</span>\n    <span class=\"hljs-meta\">[&lt;HttpGet(\"{id}\")&gt;]</span>\n    <span class=\"hljs-keyword\">member</span> this.Get(id:int) = <span class=\"hljs-string\">\"value\"</span>\n\n    <span class=\"hljs-comment\">// POST api/values</span>\n    <span class=\"hljs-meta\">[&lt;HttpPost&gt;]</span>\n    <span class=\"hljs-keyword\">member</span> this.Post(<span class=\"hljs-meta\">[&lt;FromBody&gt;]</span>value:string) = ()\n\n    <span class=\"hljs-comment\">// PUT api/values/5</span>\n    <span class=\"hljs-meta\">[&lt;HttpPut(\"{id}\")&gt;]</span>\n    <span class=\"hljs-keyword\">member</span> this.Put(id:int, <span class=\"hljs-meta\">[&lt;FromBody&gt;]</span>value:string) = ()\n\n    <span class=\"hljs-comment\">// DELETE api/values/5</span>\n    <span class=\"hljs-meta\">[&lt;HttpDelete(\"{id}\")&gt;]</span>\n    <span class=\"hljs-keyword\">member</span> this.Delete(id:int) = ()\n</code></pre>\n<p>Even though F# is a multi-paradigm language, defining object-oriented types in it always seems to go against its functional side, resulting in more verbose, less natural code.</p>\n<h2 id=\"embracing-f-s-style\">Embracing F#&#39;s Style</h2>\n<p>Now, the F# project types available with the ASP.NET Yeoman generator are really just translations of the same project types available for C#, so these won&#39;t always be inline with best practices of the F# community. If you&#39;re interested in going further down the rabbit hole, F# projects like <a href=\"https://suave.io\">Suave</a>, a simple web development library, are continuously improving their support for .NET Core, but at times, they will require some extra work to get going unless there are other templates that can be used to get your project off the ground.</p>\n<p>The Suave team is working on bringing their project into the .NET Core limelight to make the process of using Suave and F# on .NET Core as easy as possible. Under their GitHub organization, they even have a <a href=\"https://github.com/SuaveIO/Suave-CoreCLR-sample\">sample project</a> that can be used as a base for new applications. This will not use the ASP.NET Core Kestrel web server, but will instead use Suave&#39;s own HTTP server implementation.</p>\n<p>What I&#39;ll end up tinkering with is finding a way to bring Suave&#39;s HTTP routing combinators (example below) to ASP.NET and Kestrel, getting the best of both world&#39;s: Suave&#39;s F# native constructs and .NET Core&#39;s level of support and progress on the Kestrel server.</p>\n<blockquote>\n<p>Suave&#39;s HTTP routing combinators</p>\n</blockquote>\n<pre><code class=\"hljs language-fsharp\"><span class=\"hljs-keyword\">open</span> Suave\n<span class=\"hljs-keyword\">open</span> Suave.Filters\n<span class=\"hljs-keyword\">open</span> Suave.Operators\n<span class=\"hljs-keyword\">open</span> Suave.Successful\n\n<span class=\"hljs-keyword\">let</span> app =\n  choose\n    [ GET &gt;=&gt; choose\n        [ path <span class=\"hljs-string\">\"/hello\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"Hello GET\"</span>\n          path <span class=\"hljs-string\">\"/goodbye\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"Good bye GET\"</span> ]\n      POST &gt;=&gt; choose\n        [ path <span class=\"hljs-string\">\"/hello\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"Hello POST\"</span>\n          path <span class=\"hljs-string\">\"/goodbye\"</span> &gt;=&gt; OK <span class=\"hljs-string\">\"Good bye POST\"</span> ] ]\n\nstartWebServer defaultConfig app\n</code></pre>\n<p><em>Update Jan 22, 2017</em>: I&#39;ve looked into this successfully and <a href=\"https://shane.logsdon.io/posts/fiddling-with-asp-dotnet-core-and-fsharp-with-suave/\">reported my experience with ASP.NET Core and Suave</a>.</p>\n<h2 id=\"comments-to-be-made\">Comments to be Made</h2>\n<p>Even though progress is being made, there are still some short-comings that will hopefully be resolved as time goes on. F# is still second-class compared to C# and, to some extent, VB.NET in the .NET world, and .NET Core is no exception. C# is, and probably will always be, Microsoft&#39;s golden child, so a lot of the .NET Core is stil geared towards C# developers. .NET Core tooling is relatively new and still progressing, so as the F# community puts effort, the gap between F# and C# support should being to close.</p>\n"}