{"file":"posts/2016-10-29-simple-php-socket-programming.md","type":"posts","slug":"posts/simple-php-socket-programming","date":"2016-10-29T00:00:00.000Z","title":"Simple PHP Socket Programming","author":"shane","layout":"post","categories":["All Posts","Programming"],"tags":["php","sockets"],"description":"PHP isn't just for templates for Apache's mod_php. Let's have fun with socket programming in PHP.","content":"<p>While not always useful in a regular PHP web application, socket programming can be a useful tool. Think about it. Instead of being restricted to responding to HTTP requests behind Apache, nginx, etc., you can use PHP to respond to any protocol request through a long-running PHP process.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># Less of this...</span>\n$ curl http://your.server/index.php\n\n<span class=\"hljs-comment\"># ...and more of this:</span>\n$ php server.php\n</code></pre>\n<p>On our socket voyage, we&#39;re going to use <a href=\"http://php.net/manual/en/intro.stream.php\">PHP Streams</a>, a generalized way of interacting with files, network, data compression, and other operations through a single set of functions.</p>\n<p>Let&#39;s start with an overview of steps we need to take:</p>\n<ol>\n<li>Listen on a port</li>\n<li>Accept an incoming connection</li>\n<li>Read the request</li>\n<li>Send a response</li>\n<li>Close the connection</li>\n<li>Goto 2</li>\n</ol>\n<h2 id=\"1-listen-on-a-port\">1. Listen on a port</h2>\n<p>We&#39;ll use <a href=\"http://php.net/function.stream-socket-server\"><code>stream_socket_server</code></a> to listen on our desired port:</p>\n<pre><code class=\"hljs language-php\">$server = stream_socket_server($binding);\n\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">false</span> === $server) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Exception</span>(<span class=\"hljs-string\">'Could not listen'</span>);\n}\n</code></pre>\n<p><code>stream_socket_server</code>&#39;s first and only required parameter is a local socket address that follows the form <code>transport://target</code>. For example, we can set this to <code>tcp://127.0.0.1:1234</code> to create a TCP server that listens on the <code>127.0.0.1</code> address using the port <code>1234</code>.</p>\n<p>A key point here is the return value of <code>stream_socket_server</code> is a stream resource that <em>contains</em> a socket resource. The stream isn&#39;t purely the socket. What does that mean? You can use the returned resource wherever a stream resource is accepted (e.g. in the stream functions [<code>stream_socket_accept</code>, <code>stream_get_line</code>, etc.] and file functions [<code>fread</code>, <code>fclose</code>, etc.]), but regular socket functions like <code>socket_read</code> won&#39;t accept the stream as a valid socket resource. There is\n<code>socket_import_stream</code> that can expose the raw socket resource from a stream, but this doesn&#39;t work for all stream transport types.</p>\n<h3 id=\"note-about-unclosed-ports\">Note about unclosed ports</h3>\n<p>During your development, you may run across something like this:</p>\n<blockquote>\n<p>Warning: stream_socket_server(): unable to connect to tcp://127.0.0.1:1234 (Address already in use) in server.php on line 3</p>\n</blockquote>\n<p>This typically means one of two things:</p>\n<ol>\n<li>Another application is using your desired port number</li>\n<li>Your application is still running from a previous execution</li>\n</ol>\n<p>If you&#39;re using a free port number, the above warning is most likely caused by your own code still running. You can correct this by stopping other <code>php</code> processes on your development machine through Task Manager, Activity Monitor, or something like <code>killall php</code>. This can happen if your code exits prematurely, if an uncaught exception or other fatal error occurs for instance.</p>\n<h2 id=\"2-accept-an-incoming-connection\">2. Accept an incoming connection</h2>\n<p>To actually work allow clients to use our server, we will need to accept their incoming connection attempts, using <a href=\"http://php.net/function.stream-socket-accept\"><code>stream_socket_accept</code></a> to accomplish this:</p>\n<pre><code class=\"hljs language-php\">$client = stream_socket_accept($server);\n\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">false</span> !== $client) {\n    <span class=\"hljs-comment\">// valid client connection</span>\n}\n</code></pre>\n<p><code>stream_socket_accept</code>&#39;s first and only required parameter is an active server stream resource and returns another stream resource for the client. This function will block process execution while it waits for a client to connect.</p>\n<p>This waiting period will last until <code>stream_socket_accept</code>&#39;s timeout is reached. The timeout period defaults to <code>ini_get(&quot;default_socket_timeout&quot;)</code>, which can be changed either globally in your active <code>php.ini</code> file or locally through <code>stream_socket_accept</code>&#39;s second argument. If changing the default timeout, be sure to set the value to an appropriate value in seconds for your use case.</p>\n<h2 id=\"3-read-the-request\">3. Read the request</h2>\n<p>Once a client has established a connection with the server, it will want something from the server, so it&#39;s the server&#39;s task to figure that out by reading the client&#39;s request from the stream (and eventually respond to it). Here are a couple of stream-centric ways of acquiring data from a client request:</p>\n<pre><code class=\"hljs language-php\">$firstLine = stream_get_line($client, $maxLength, $ending);\n$restOfContents = stream_get_contents($client);\n</code></pre>\n<p><a href=\"http://php.net/function.stream-get-line\"><code>stream_get_line</code></a> will read from the stream until one of these things occurs:</p>\n<ol>\n<li><code>$maxLength</code> bytes are read</li>\n<li><code>$ending</code> characters are reached</li>\n<li>EOF (end-of-file character) is read</li>\n</ol>\n<p>When <a href=\"http://php.net/function.stream-socket-accept\"><code>stream_get_contents</code></a> is called in this case, it will continue to read where <code>stream_get_line</code> left off, reading until EOF is read. This behavior can be changed by specifying either/both of the <code>$maxLength</code> and <code>$offset</code> parameters, but by default, reading will start at the stream&#39;s pointer&#39;s current position and will read the remainder of the stream.</p>\n<h2 id=\"4-send-a-response\">4. Send a response</h2>\n<p>Just like with file descriptors, socket streams can be full-duplex (they are by default), meaning you can read and write to a single client stream. After reading from a client stream, you will be able to write your response without closing a &quot;read-only stream&quot; nor opening a &quot;write-only stream&quot;:</p>\n<pre><code class=\"hljs language-php\">$contents = stream_get_contents($client);\n<span class=\"hljs-comment\">// do something with $contents</span>\nstream_socket_sendto($client, $responseData);\n</code></pre>\n<p>A benefit <a href=\"http://php.net/function.stream-socket-sendto\"><code>stream_socket_sendto</code></a> has over, say, <code>fwrite</code> is that it can be used to send out of band data (specially flagged data when sent via TCP) as well:</p>\n<pre><code class=\"hljs language-php\">stream_socket_sendto($client, $data, STREAM_OOB);\n</code></pre>\n<p>Out of band data could be used to send notification flags to the client, but if used, you will need to ensure clients are able to handle this data properly.</p>\n<h2 id=\"5-close-the-connection\">5. Close the connection</h2>\n<p>Once a response has been sent, the server has the option to keep the connection open for future requests from the client or close the client&#39;s connection. <a href=\"http://php.net/function.stream-socket-shutdown\"><code>stream_socket_shutdown</code></a> provides a simple way to ensure a stream is closed properly, giving three options on how that stream is closed:</p>\n<ul>\n<li><code>STREAM_SHUT_RD</code> prevents further reading</li>\n<li><code>STREAM_SHUT_WR</code> prevents further writing</li>\n<li><code>STREAM_SHUT_RDWR</code> prevents further reading and writing</li>\n</ul>\n<p>In most cases, you will want to completely close the stream, so <code>STREAM_SHUT_RDWR</code> is the best choice:</p>\n<pre><code class=\"hljs language-php\">stream_socket_shutdown($client, STREAM_SHUT_RDWR);\n</code></pre>\n<h2 id=\"6-goto-2\">6. Goto 2</h2>\n<p>If you want to accept more than one client&#39;s connection without needing to restart your server, you will want to create a loop to accept a new client after closing another&#39;s connection:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n    $client = stream_socket_accept($server);\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">false</span> !== $client) {\n        <span class=\"hljs-comment\">// interact with client</span>\n    }\n}\n</code></pre>\n<p>With this, our application will start blocking again while it waits for a new client connection, and it will continue to do so until an uncaught fatal error occurs or the process group receives an interrupt signal (<code>SIGINT</code> or <code>Ctrl-C</code>) or termination request signal (<code>SIGTERM</code>).</p>\n<p>Some experience with PHP may have alerted you to something interesting about looping this way. Since PHP is single-threaded (it runs a script in one process thread by default), you will only be able to accept one client connection at any given time. If you have a requirement for accepting more than one client at a time, you will have to add additional code to offer that functionality.</p>\n<h2 id=\"bonus-multi-processing\">Bonus: Multi-processing</h2>\n<p>Without using additional extensions (<code>ext-libevent</code>, <code>ext-libev</code>, <code>ext-event</code>, etc.), you can leverage the <a href=\"http://php.net/manual/en/book.pcntl.php\">PCNTL extension</a> to fork your parent process:</p>\n<blockquote>\n<p>Note: While this is typically available from PHP distributions, it&#39;s not enabled by default when compiling from source, and it&#39;s not available in Windows environments.</p>\n</blockquote>\n<pre><code class=\"hljs language-php\">$i = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">while</span> ($i++ &lt; $num_acceptors - <span class=\"hljs-number\">1</span>) {\n    $pid = pcntl_fork();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">-1</span> === $pid) {\n        error_log(<span class=\"hljs-string\">'could not fork'</span>);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> ($pid) {\n        <span class=\"hljs-comment\">// parent. continue spawning.</span>\n        error_log(sprintf(<span class=\"hljs-string\">'spawned %s'</span>, $i));\n        <span class=\"hljs-keyword\">continue</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// child. go to accepting</span>\n        <span class=\"hljs-keyword\">break</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n    <span class=\"hljs-comment\">// accept client connections</span>\n}\n</code></pre>\n<p>The above code contains two <code>while</code> loops: one to create the child forks from the parent and one to get all process accepting client connections. In the first loop, we fork the parent process <code>$num_acceptors - 1</code> times as we are going to use the parent process to accept connections as well.</p>\n<blockquote>\n<p>Caution: This is purely for explanatory reasons. In a production/production-like environment, your parent process should only manage child forks. If your parent does work and exits prematurely, it could kill currently running child processes as well. Bad news!</p>\n</blockquote>\n<h2 id=\"an-echo-server\">An echo server</h2>\n<p>Putting it all together, a simple echo server using PHP streams may looks something like this:</p>\n<pre><code class=\"hljs language-php\">$binding = <span class=\"hljs-string\">'tcp://0.0.0.0:1234'</span>;\n$server = stream_socket_server($binding);\n\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">false</span> === $server) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Exception</span>(<span class=\"hljs-string\">'Could not listen'</span>);\n}\n\n<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n    $client = stream_socket_accept($server);\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">false</span> !== $client) {\n        stream_copy_to_stream($client, $client);\n    }\n}\n</code></pre>\n<p>We used <a href=\"http://php.net/function.stream-copy-to-stream\"><code>stream_copy_to_stream</code></a> to simplify reading data from the client and sending that exact data back to the client. Here&#39;s a sample <code>telnet</code> session of our server in action:</p>\n<pre><code class=\"hljs language-bash\">$ telnet 127.0.0.1 1234\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is <span class=\"hljs-string\">'^]'</span>.\nhello\nhello\nConnection closed by foreign host.\n</code></pre>\n<p>Success! Be sure to remember that we&#39;ve only scratched the surface here with what&#39;s possible with socket programming in PHP. There are loads more use cases than simple echo servers, and there are more options for reading from and writing to sockets, managing those sockets, etc. through PHP&#39;s various stream-capable functions.</p>\n"}